## 面试题 08.11. 硬币凑整

给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

>   示例1:
>
>   输入: n = 5 
>
>   输出：2 
>
>   解释: 有两种方式可以凑成总金额: 5=5 5=1+1+1+1+1
>
>   示例2:
>
>   输入: n = 10 
>
>   输出：4 
>
>   解释: 有四种方式可以凑成总金额: 10=10 10=5+5 10=5+1+1+1+1+1 10=1+1+1+1+1+1+1+1+1+1
>
>   说明：
>
>   你可以假设：0 <= n (总金额) <= 1000000

```java
class Solution {
    public int waysToChange(int n) {       
        int[] dp = new int[n + 1];      
        int[] coins = new int[]{1,5,10,25};
        //刚好可以用一个硬币凑成的情况，是一种情况
        // while i == coin :
        //dp[i] = dp[i - coin] => dp[0]
        dp[0] = 1;
        /**
        * dp方程：dp[i] += dp[i - coin];
        */
        for(int coin : coins) {
            for(int i = coin; i <= n; i++) {
                dp[i] = (dp[i] + dp[i - coin]) % 1000000007;
            }
        }
        return dp[n];
    }
}
```

## 面试题51. 数组中的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

>   示例 1:
>
>   输入: [7,5,6,4]
>
>   输出: 5
>
>
>   限制：0 <= 数组长度 <= 50000

```java
class Solution {
    public int reversePairs(int[] nums) {
        return merge(nums, 0, nums.length - 1);
    }
    int merge(int[] arr, int start, int end) {
        if (start >= end) return 0;
        int mid = start + (end - start) / 2;
        int count = merge(arr, start, mid) + merge(arr, mid + 1, end);

        int[] temp = new int[end - start + 1];
        int i = start, j = mid + 1, k = 0;
        while (i <= mid && j <= end) {
            count += arr[i] <= arr[j] ? j - (mid + 1) : 0;
            temp[k++] = arr[i] <= arr[j] ? arr[i++] : arr[j++];
        }
        while (i <= mid) {
            count += j - (mid + 1);
            temp[k++] = arr[i++];
        }
        while (j <= end){
            temp[k++] = arr[j++];
        }  
        System.arraycopy(temp, 0, arr, start, end - start + 1);
        return count;
    }
}
```

## 3. 无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

>   示例 1:
>
>   输入: "abcabcbb"
>
>   输出: 3 
>
>   解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
>
>   示例 2:
>
>   输入: "bbbbb"
>
>   输出: 1
>
>   解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
>
>   示例 3:
>
>   输入: "pwwkew"
>
>   输出: 3
>
>   解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>
>   请注意，你的答案必须是 `子串` 的长度，"pwke" 是一个子序列，不是子串。
>

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length()==0) {
            return 0;
        }
        HashMap<Character, Integer> map = new HashMap<Character, Integer>();
        //记录最大长度
        int max = 0;
        //记录最左开始字母下标
        int left = 0;
        for(int i = 0; i < s.length(); i ++){
            if(map.containsKey(s.charAt(i))){
                //更新最左开始字母下标
                left = Math.max(left,map.get(s.charAt(i)) + 1);
            }
            map.put(s.charAt(i),i);
            max = Math.max(max,i-left+1);
        }
        return max;
    }
}
```

## 11. 盛最多水的容器

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

>   说明：你不能倾斜容器，且 n 的值至少为 2。
>
>   示例：
>
>   输入：[1,8,6,2,5,4,8,3,7]
>
>   输出：49

```java
/*
在每一个状态下，无论长板或短板收窄1格，都会导致水槽底边宽度−1：
若向内移动短板，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 可能变大，因此水槽面积 S(i, j)S(i,j) 可能增大。
若向内移动长板，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 不变或变小，下个水槽的面积一定小于当前水槽面积。
因此，向内收窄短板可以获取面积最大值。
*/
class Solution {
    public int maxArea(int[] height) {
        int res = 0, i = 0, j = height.length - 1;
        while (i < j){
            if(height[i] <= height[j]){
                res = Math.max(res, height[i] * (j - i));
                i++;
            }else{
                res = Math.max(res, height[j] * (j - i));
                j--;
            }
        }
        return res;
    }
}
```

## 23. 合并K个排序链表

合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

>   示例:
>
>   输入:
>   [
>     1->4->5,
>     1->3->4,
>     2->6
>   ]
>
>   输出: 1->1->2->3->4->4->5->6

**利用堆做排序**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists==null || lists.length==0) {
            return null;
        }
        //创建一个堆，并设置元素的排序方式
        PriorityQueue<ListNode> queue = new PriorityQueue(new Comparator<ListNode>() {
            public int compare(ListNode o1, ListNode o2) {
                return (o1.val - o2.val);
            }
        });

		//遍历链表数组，然后将每个链表的每个节点都放入堆中
		for(int i = 0;i < lists.length; i++) {
			while(lists[i] != null) {
				queue.add(lists[i]);
				lists[i] = lists[i].next;
			}
		}   
        ListNode dummy = new ListNode(-1);
        ListNode head = dummy;
        //从堆中不断取出元素，并将取出的元素串联起来
        while( !queue.isEmpty() ) {
            dummy.next = queue.poll();
            dummy = dummy.next;
        }
        dummy.next = null;
        return head.next;
    }
}
```

**堆排序优化**

我们建立完k个大小的堆后，就不断的从堆中获取节点，如果获取到的节点不为空，即还有下一个节点，那么就将下一个节点放到堆中。利用这个特点我们就可以优化空间了，将原先的O(N)的空间复杂度优化到O(k)。

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists==null || lists.length==0) {
            return null;
        }
        //创建一个小根堆，并定义好排序函数
        PriorityQueue<ListNode> queue = new PriorityQueue(new Comparator<ListNode>() {
            public int compare(ListNode o1, ListNode o2) {
                return (o1.val - o2.val);
            }
        });
        ListNode dummy = new ListNode(-1);
        ListNode cur = dummy;
        //这里跟上一版不一样，不再是一股脑全部放到堆中
        //而是只把k个链表的第一个节点放入到堆中
        for(int i = 0; i < lists.length; i++) {
            ListNode head = lists[i];
            if(head!=null) {
                queue.add(head);
            }
        }
        //之后不断从堆中取出节点，如果这个节点还有下一个节点，
        //就将下个节点也放入堆中
        while(queue.size() > 0) {
            ListNode node = queue.poll();
            cur.next = node;
            cur = cur.next;
            if(node.next!=null) {
                queue.add(node.next);
            }
        }
        cur.next = null;
        return dummy.next;
    }
}
```

**两两合并**

对于这四个链表，我们先合并A1和A2，将这两个链表变成A1-A2，然后再按照两两合并的方式，合并A1-A2和A3，这三个链表就合并成了A1-A2-A3，最后将A1-A2-A3跟A4两两合并，四个链表就合并完了。

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists==null || lists.length==0) {
            return null;
        }
        //将lists[0]作为最终合并的链表，然后将list[0]和lists[1]合并成lists[0-1]
        //再将lists[0-1]和lists[2]合并，如此反复最终lists[0]就是最终结果
        ListNode res = lists[0];
        for(int i=1;i<lists.length;i++) {
            res = merge(res,lists[i]);
        }
        return res;
    }

    //合并两个有序链表
    private ListNode merge(ListNode a, ListNode b) {
        if(a==null || b==null) {
            return (a==null) ? b : a;
        }
        if(a.val<=b.val) {
            a.next = merge(a.next,b);
            return a;
        } else {
            b.next = merge(a,b.next);
            return b;
        }
    }
}
```

## 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

>   示例 1:
>
>   输入: [1,3,5,6], 5
>
>   输出: 2
>
>   示例 2:
>
>   输入: [1,3,5,6], 2
>
>   输出: 1
>
>   示例 3:
>
>   输入: [1,3,5,6], 7
>
>   输出: 4
>
>   示例 4:
>
>   输入: [1,3,5,6], 0
>
>   输出: 0

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        //下标小于low的值都小于target
        int low = -1;
        //下标大于high的值都大于target
        int high = nums.length;
        //当low和high之间有值时不断循环
        while(low + 1 < high){
            int mid = (low + high) / 2;
            if(nums[mid] >= target){
                high = mid;
            }else{
                low = mid;
            }
        }
        return high;
    }
}
```

## 46. 全排列

给定一个 没有重复 数字的序列，返回其所有可能的全排列。

>   示例:
>
>   输入: [1,2,3]
>
>   输出:
>   [
>     [1,2,3],
>     [1,3,2],
>     [2,1,3],
>     [2,3,1],
>     [3,1,2],
>     [3,2,1]
>   ]

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();

    /* 主函数，输入一组不重复的数字，返回它们的全排列 */
    public List<List<Integer>> permute(int[] nums) {
        // 记录「路径」
        LinkedList<Integer> track = new LinkedList<>();
        backtrack(nums, track);
        return res;
    }

    // 路径：记录在 track 中
    // 选择列表：nums 中不存在于 track 的那些元素
    // 结束条件：nums 中的元素全都在 track 中出现
    void backtrack(int[] nums, LinkedList<Integer> track) {
        // 触发结束条件
        if (track.size() == nums.length) {
            res.add(new LinkedList(track));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
            // 排除不合法的选择
            if (track.contains(nums[i]))
                continue;
            // 做选择
            track.add(nums[i]);
            // 进入下一层决策树
            backtrack(nums, track);
            // 取消选择
            track.removeLast();
        }
    }
}
```

## 55. 跳跃游戏

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

>   示例 1:
>
>   输入: [2,3,1,1,4]
>
>   输出: true
>
>   解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
>
>   示例 2:
>
>   输入: [3,2,1,0,4]
>
>   输出: false
>
>   解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。

```java
class Solution {
    public boolean canJump(int[] nums) {
        //记录当前最大跳跃距离
        int maxLen = 0;
        for(int i = 0; i < nums.length; i++){
            //如果当前坐标大于最大跳跃距离，则当前坐标不可达，返回false
            if(i > maxLen){
                return false;
            }
            //否则更新最大跳跃距离
            maxLen = Math.max(maxLen, i + nums[i]);
        }
        return true;
    }
}
```

## 152. 乘积最大子数组

给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

>   示例 1:
>
>   输入: [2,3,-2,4]
>
>   输出: 6
>
>   解释: 子数组 [2,3] 有最大乘积 6。
>
>   示例 2:
>
>   输入: [-2,0,-1]
>
>   输出: 0
>
>   解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。

```java
class Solution {
    public int maxProduct(int[] nums) {
        int max = nums[0], min = nums[0], result = nums[0];
        //由于数组中含有负数，需要同时维护max和min
        for (int i = 1; i < nums.length; i++) {
            int temp = max;
            //max 取 max * nums[i]、min * nums[i]、nums[i]中的最大值
            max = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);
            //min 取 temp * nums[i]、min * nums[i]、nums[i]中的最小值
            min = Math.min(Math.min(temp * nums[i], min * nums[i]), nums[i]);
            //记录最大值
            if (max > result) result = max;
        }
        return result;
    }
}
```

## 210. 课程表 II

现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

>   示例 1:
>
>   输入: 2, [[1,0]] 
>
>   输出: [0,1]
>
>   解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
>
>   示例 2:
>
>   输入: 4, [[1,0],[2,0],[3,1],[3,2]]
>
>   输出: [0,1,2,3] or [0,2,1,3]
>
>   解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        //课程数为0，直接返回空数组
        if (numCourses == 0) return new int[0];
        // 建立入度表
        int[] inDegrees = new int[numCourses];
        // 对于有先修课的课程，计算有几门先修课
        for (int[] p : prerequisites) { 
            inDegrees[p[0]]++;
        }
        Queue<Integer> queue = new LinkedList<>();
        // 入度为0的节点,加入队列，表示可以直接学习
        for (int i = 0; i < inDegrees.length; i++) {
            if (inDegrees[i] == 0) queue.offer(i);
        }
        // 记录学完的课程数量
        int count = 0;
        // 记录学完的课程
        int[] res = new int[numCourses];
        // 根据提供的先修课列表，删除入度为0的节点
        while (!queue.isEmpty()){
            //将可以学完的课程加入结果当中
            int curr = queue.poll();
            res[count++] = curr;
            for (int[] p : prerequisites) {
                //将先修课程为curr的节点入度减1
                if (p[1] == curr){
                    inDegrees[p[0]]--;
                    //如果节点入度为0，则加入队列，代表可以直接学习
                    if (inDegrees[p[0]] == 0) queue.offer(p[0]);
                }
            }
        }
        //如果已学习课程数count等于总数numCourses，则返回结果res
        if (count == numCourses) return res;
        //否则返回空数组
        return new int[0];
    }
}
```

## 402. 移掉K位数字

给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

注意:

num 的长度小于 10002 且 ≥ k。
num 不会包含任何前导零。

>   示例 1 :
>
>   输入: num = "1432219", k = 3
>
>   输出: "1219"
>
>   解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
>
>   示例 2 :
>
>   输入: num = "10200", k = 1
>
>   输出: "200"
>
>   解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
>
>   示例 3 :
>
>   输入: num = "10", k = 2
>
>   输出: "0"
>
>   解释: 从原数字移除所有的数字，剩余为空就是0。

```java
class Solution {
    public String removeKdigits(String num, int k) {
        if (num.length() == k) {
            return "0";
        } 
        StringBuilder s = new StringBuilder(num);
        //共删除k次
        for (int i = 0; i < k; i++) {
            int idx = 0;
            //找到持续增加的区间最后的数字，也就是最大的数字下标idx
            for (int j = 1; j < s.length() && s.charAt(j) >= s.charAt(j - 1); j++) {
                idx = j;
            }
            //删除idx
            s.delete(idx, idx + 1);
            //特殊情况：删除最大数后第一位为0
            while (s.length() > 1 && s.charAt(0) == '0'){
                s.delete(0, 1);
            }
        }
        return s.toString();
    }
}
```

