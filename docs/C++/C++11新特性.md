# C++11新特性

>   参考文档：https://www.jianshu.com/p/d0a98e0eb1a8

C++ 11中引入了大量非常有用的特性，使代码更直观、安全、简洁、方便。

## 初始化列表 Initializer List

所有STL容器都支持初始化列表，如下：

```cpp
std::vector<int> v = { 1, 2, 3 };
std::list<int> l = { 1, 2, 3 };
std::set<int> s = { 1, 2, 3 };
std::map<int, std::string> m = { {1, "a"}, {2, "b"} };
```

在自定义`class`上支持初始化列表

```cpp
#include <initializer_list>

class A {
public:
    B(const std::initializer_list<int>& items)
        : m_items(items)
    {}

private:
    std::vector<int> m_items;
};

A a1 = { 1, 2, 3 };
// 或者
A a2{ 1, 2, 3 };
```

## 统一的初始化方法 Uniform Initialization

可以统一使用大括号`{}`进行初始化。对构造函数的选择的优先级如下：

```cpp
class A {
public:
    // first choice
    A(const std::initializer_list<int>& v) : age(*v.begin())
    {}

    // second choice
    A(int age) : age(age)
    {}

    // third choice
    int age;
};

A a{ 5 };
```

上面的调用会选择带初始化列表的构造函数。

```cpp
class A {
public:
    A() {}

    int age;
};

A a{ 5 };
```

这个代码会编译出错。因为存在构造函数，但函数签名又不匹配。换言之，只要存在自定义的构造函数，就要求至少有一个构造函数的参数列表与大括号中的参数完全匹配，才能使用这种方式初始化。

## 类型推导 Auto Type

过去的这种冗长的类型声明

```cpp
std::map<int, std::string>::const_iterator itr = m.find(1);
```

现在可以写成这样了

```cpp
auto itr = m.find(1);
```

编译器会自动推导出正确的类型。字面量也可以：

```cpp
auto i = 1;          // int
auto d = 1.1;        // double
auto s = "hi";       // const char*
auto a = { 1, 2 };   // std:: initializer_list<int>
```

如果是用Visual Studio，把鼠标悬停在变量名上方，可以看到推导后的类型名称。类型推导对于泛型编程非常方便，比如：

```cpp
template<typename T, typename K>
auto add(T a, K b) {
    return a + b;
}

auto a = add(1, 2);     // int add(int, int)
auto b = add(1, 2.2);   // double add(int, double)
```

留意第二个调用，返回值被正确地推断为`double`类型。

## 遍历 foreach

以前遍历`vector`一般是这么写的

```cpp
for (std::vector<int>::const_iterator itr = v.begin(); itr != v.end(); ++itr) {
    std::cout << *itr << std::endl;
}
```

这样写有两个缺点：

1.  迭代器声明很冗长 （用`auto`可以部分解决）
2.  循环内部必须对迭代器解引用（主要是难看）

可以使用的新的遍历方式：

```cpp
for (int i : v) {
    std::cout << i << std::endl;
}
```

代码立马简洁了许多。但是要注意，这里每次循环，会对`i`进行一次拷贝。此处`i`是一个`int`值，拷贝不会造成问题，但是如果是一个`class`，我们就更希望用引用的方式进行遍历，一般写成：

```cpp
std::vector<string> v = { "a", "b" };

for (auto& s : v) {
    std::cout << s << std::endl;
}
```

用`auto&`即可以变成引用方式遍历，甚至还能在循环中改变它的值。也可以使用`const auto&`，只是一般没有必要。

## 空指针 nullptr

以往我们使用`NULL`表示空指针。它实际上是个为0的`int`值。下面的代码会产生岐义：

```cpp
void f(int i) {} // chose this one
void f(const char* s) {}

f(NULL);
```

为此`C++ 11`新增类型`nullptr_t`，它只有一个值`nullptr`。上面的调用代码可以写成:

```cpp
void f(int i) {}
void f(const char* s) {} // chose this one

f(nullptr);
```

## 强类型枚举 enum class

原来的`enum`有两个缺点：

1.  容易命名冲突
2.  类型不严格

如下代码：

```rust
enum Direction {
    Left, Right
};

enum Answer {
    Right, Wrong
};
```

此代码编译报错：`Right`重定义。这里使用了单个单词作为名称，很容易出现冲突。所以我们一般加个前缀，变成：

```rust
enum Direction {
    Direction_Left, Direction_Right
};

enum Answer {
    Answer_Right, Answer_Wrong
};
```

这样写很难看，而且如果这两个枚举是分别从两个第三方库引入的，那就无法自己改名字了。而且改成这样依然有个问题：

```cpp
auto a = Direction_Left;
auto b = Answer_Right;

if (a == b)
    std::cout << "a == b" << std::endl;
else
    std::cout << "a != b" << std::endl;
```

这个代码将输出`a == b`，因为这两上值都为0。然而允许两个不同类型的值作比较，就是不合理的，容易隐藏一些bug。

`C++ 11`引入了`enum class`：

```cpp
enum class Direction {
    Left, Right
};

enum class Answer {
    Right, Wrong
};

auto a = Direction::Left;
auto b = Answer::Right;

if (a == b)
    std::cout << "a == b" << std::endl;
else
    std::cout << "a != b" << std::endl;
```

*   引用时必须加上枚举名称(`Direction_Left`变成`Direction::Left`)，似乎写法上差不多，但是这样类型更加严格。下面的`a == b`编译将会报错，因为它们是不同的类型。
*   枚举值不再是全局的，而是限定在当前枚举类型的域内。所以使用单个单词作为值的名称也不会出现冲突。

## 静态断言 static assert

`static_assert`可在编译时作判断。

```cpp
static_assert( size_of(int) == 4 );
```

## 构造函数的相互调用 delegating constructor

同一个`class`的多个构造函数的内部实现通常非常相似，比如：

```cpp
class A {
public:
    A(int x, int y, const std::string& name) : x(x), y(y), name(name) {
        if (x < 0 || y < 0)
            throw std::runtime_error("invalid coordination");
        // other stuff
    }

    A(int x, int y) : x(x), y(y), name("A") {
        if (x < 0 || y < 0)
            throw std::runtime_error("invalid coordination");
        // other stuff
    }

    A() : x(0), y(0), name("A") {
        // other stuff
    }

private:
    int x;
    int y;
    std::string name;
};
```

为了避免重复代码，通常会把共同的代码挪到一个`init`成员函数里：

```cpp
class A {
public:
    A(int x, int y, const std::string& name) {
        init(x, y, name);
    }

    A(int x, int y) {
        init(x, y, "A");
    }

    A() {
        init(0, 0, "A");
    }

private:
    void init(int x, int y, const std::string& name) {
        if (x < 0 || y < 0)
            throw std::runtime_error("invalid coordination");
        this->x = x;
        this->y = y;

        if (name.empty())
            throw std::runtime_error("empty name");
        this->name = name;

        // other stuff
    }

private:
    int x;
    int y;
    std::string name;
};
```

这样写有三个问题：

1.  二次赋值。执行到`init`函数时，数据成员实际已经初始化了。比如`name`成员，此时已经初始化为一个空字符串了。这里实际上是又调用了一次“`=`”操作符。对于初始化成本比较高的类型，这样做就有可能影响性能了。
2.  只能调用成员的无参构造函数。只有构造函数的初始化列表才能调用成员的带参数构造函数。
3.  无法保证`init`只被调用一次。有些初始化步骤必须保证只被执行一次，这一点只有构造函数可以保证。

`C++ 11`允许构造函数之间相互调用了：

```cpp
class A {
public:
    A(int x, int y, const std::string& name) : x(x), y(y), name(name) {
        if (x < 0 || y < 0)
            throw std::runtime_error("invalid coordination");
        if (name.empty())
            throw std::runtime_error("empty name");
        // other stuff
    }

    A(int x, int y) : A(x, y, "A")
    {}

    A() : A(0, 0)
    {}

private:
    int x;
    int y;
    std::string name;
};
```

除了优雅地解决了上述三个问题之外，代码也简洁了许多，连`name`成员的默认值`"A"`也只需要写一次。

## 禁止重写 final

*   禁止虚函数被重写

```cpp
class A {
public:
    virtual void f1() final {}
};

class B : public A {
    virtual void f1() {}
};
```

此代码编译报错，提示不能重写`f1`。虽然`f1`是虚函数，但是因为有`final`关键字，保证它不会被重写。你可能会说，那不声明`virtual`不就完了。但是如果`A`本身也有基类，`f1`是继承下来的，那`virtual`就是隐含的了。

*   禁止类被继承

```cpp
class A final {
};

class B : public A {
};
```

此代码编译报错，提示不能继承`A`。